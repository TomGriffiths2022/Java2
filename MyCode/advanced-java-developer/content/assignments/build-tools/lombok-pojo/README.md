<img src="https://github.com/stayahead-training/shared/blob/master/stayahead.png" />

# Build Tools Assignment

## Lombok POJO

[<< back](../../../../README.md#build-tools)

You're going to build a simple Java app with Maven that uses Lombok (a Java library) to simplify the creation of POJO classes.

### Part 1

1. Create a new *Maven* project named `lombok-pojo`. Do not select an archetype, nor should you input artifact coordinates.

2. Add to the POM a dependency for lombok (org.projectlombok:lombok).<details>
    <summary>Show me</summary>

    ```xml
    <dependencies>
      <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.12</version>  <!-- or whatever is the latest version -->
      </dependency>
    </dependencies>
    ```

3. Add a packages to the src/main/java directory named `org.example.lombokpojo`.

4. Add a class to the org.example.lombokpojo package named `Country`.

5. Each country is comprised of a name, a capital city, an official language, and a population. Add fields to the Country class to represent these attributes.<details>
    <summary>Show me</summary>

    ```java
    private String name;
    private String capitalCity;
    private String officialLanguage;
    private int population;
    ```
</details>

6. By adding its annotations to your class Lombok will create for you the constructors and getters & setters etc. Annotate the Country class with Lombok's `@Data` and `@AllArgsConstructor` annotations.<details>
    <summary>Show me</summary>

    ```java
    @Data                 // create getters & setters etc.
    @AllArgsConstructor   // create a constructor that accepts one arg for each field
    public class Country {
      ...
    }
    ```

</details>

7. Try executing Maven's compile phase. Execute the following command in the built-in terminal located at the bottom of the IntelliJ window.

   `$> mvn compile`<br />

   Do you see an error stating that Java version 5 is not supported? 

8. Copy and paste the following into the POM:

   ```xml
   <build>
     <plugins>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-compiler-plugin</artifactId>
           <version>3.8.0</version> <!-- or whatever is the latest version -->
           <executions>
             <execution>
               <id>default-compile</id>
               <phase>compile</phase>
               <goals>
                 <goal>compile</goal>
               </goals>
             </execution>
             <execution>
               <id>default-testCompile</id>
               <phase>test-compile</phase>
               <goals>
                 <goal>testCompile</goal>
               </goals>
             </execution>
           </executions>
           <configuration>   <!-- add start -->
             <release>11</release>
           </configuration>  <!-- add end -->
         </plugin>
      </plugins>
    </build>
   ```

   Don't be daunted by this. A plugin is effectively some code that performs one of Maven's goals. What you've done here is to configure the compiler plugin. You can see that it is responsible for compiling both source code and test code, and that it is associated with the compile and testCompile phases. Historically you'd need not have had to configure this - the configuration inhertied from the Super POM would have been satisfactory. However (and for reasons unknown) Maven assumes Java version 5! We've changed only the plugin version number and added the `configuration` and `release` tags, to tell Maven which version of the Java compiler to use. If you have to do something similar in future the simplest thing to do (in our view) is to copy and paste from the Effective POM and make only the changes that are required. You can access the Effective POM (the merger of the Super POM and the POM) by right-clicking on the project name and selecting Maven | Show Effective POM.

9. Execute Maven's compile phase again! Note that a new directory named target appears in the project explorer. It contains the bytecode generated by compiling your source code. Let's now look at the Maven lifecycles, phases, and goals in more detail.

### Part 2

1. Execute Maven's clean lifecycle. This will delete the target directory and its contents.

   `$> mvn clean`<br />

   Look at the output and observe that the clean lifecycle is comprised of only one phase, and that that phase is executed by the maven-clean-plugin.

2. Execute Maven's compile phase.

   `$> mvn compile`<br />

   Look at the output and observe that Maven executes not only the compile phase but also each preceding one. In this case that means executing first the resources phase and then the compile phase. Note too that the target directory has been recreated. But why a directory named target?

3. View the Effective POM by right-clicking on the project name and selecting Maven | Show Effective POM. Search for `outputDirectory` and note the tag's value. The Super POM dictates that the generated bytecode be written to a directory named target. You could change this by adding outputDirectory tags with a new value to the POM.

4. Execute Maven's package phase.

   `$> mvn package`<br />

   Look at the output and observe that Maven executes not only the package phase but also each preceding one. In this case that means executing (in order) the phases resources, compile, testResources, testCompile, test, and jar. It's this last one (jar) that does the packaging of your app into a JAR file. You'll find the JAR in the target directory.

5. Execute Maven's install phase.

   `$> mvn install`<br />

   Look again at the output and observe that Maven executes all phases up to and including the install one. The install phase has the effect of copying the JAR into Maven's local repository. This means it can be used in other projects by adding a dependency that looks like this:

   ```xml
   <depedency>
     <groupId>org.example</groupId>
     <artifactId>lombok-pojo</artifactId>
     <version>1.0-SNAPSHOT</version>
   </dependency>
   ```

### Part 3

Let's add a test class to verify that Lombok does indeed create the constructors and getters & setters etc.

1. Add to the POM a dependency for junit (junit:junit).<details>
    <summary>Show me</summary>

    ```xml
    <dependencies>
      ...
      <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.13</version> <!-- or whatever is the latest version -->
      </dependency>
    </dependencies>
    ```
</details>

2. Add a package to the src/test/java directory named `org.example.lombokpojo`. Note that your test packages should mirror your source packages. Doing so means that you don't have to import the class under test.

3. Add a class to the org.example.lombokpojo package named `CountryTest`.

4. Add a field of type Country to the CountryTest class named `uk`.<details>
    <summary>Show me</summary>

    ```java
    private Country uk;
    ```
</details>

5. Add a method to the CountryTest class named `setUp` and annotate it with `@Before`. It should initialise the instance field with a new Country object.<details>
    <summary>Show me</summary>

    ```java
    @Before
    public void setUp() {
      uk = new Country("UK", "London", "English", 66_000_000);
    }
    ```
</details>

6. Add a method to the CountryTest class named `testGetName` and annotate it with `@Test`. It should assert that the Country object's name is `UK`.<details>
    <summary>Show me</summary>

    ```java
    @Test
    public void testGetName() {
      assertThat(uk.getName(), is("UK"));
    }
    ```
</details>

7. Add a method to the CountryTest class named `testSetName` and annotate it with `@Test`. It should set the name of the Country object to `United Kingdom` and then asset that it is so.<details>
    <summary>Show me</summary>

    ```java
    @Test
    public void testSetName() {
      uk.setName("United Kingdom");
      assertThat(uk.getName(), is("United Kingdom"));
    }
    ```
</details>

8. Execute Maven's clean lifecycle.

   `$> mvn clean`<br />

9. Execute Maven's test phase.

   `$> mvn test`<br />

   Look at the output and observe that Maven executes not only the test phase but also each preceding one. In this case that means executing (in order) the phases resources, compile, testResources, testCompile, and test. Can you see that the test phase involves the executing of your tests? 
   
10. Assuming you've no failures have Maven re-install your app.

    `$> mvn install`<br />

[<< back](../../../../README.md#build-tools)